\chapter{Accenni al funzionamento di un calcolatore}
Un calcolatore è generalmente composto da:
\begin{itemize}
  \item la $CPU$, esegue le istruzioni, tiene in memoria ($Instruction Register$)
    l'istruzione corrente e la posizione dell'istruzione nella RAM ($P.C.$);
  \item la $RAM$, tiene in memoria le istruzioni da eseguire, certe sezioni
    sono riservate per specifiche funzioni ($stack$, $SP$, $BP$);
  \item dei moduli, come un disco fisso o altro;
  \item la $NIC$, che permette di inviare e ricevere pacchetti in rete.
\end{itemize}

\section{Networking}
Vengono effettuate delle syscall, per eseguire operazioni necessario all'invio
di dati.
Per esempio la syscall send, copia dalla ram una certa sezione di memoria nel
NIC, che verrà inviata in rete.

\subsection{TCP/UDP}
\begin{figure}[t]
\includegraphics[width=.8\textwidth]{gfx/chadudp.jpg}
\centering
\end{figure}

Il protocollo TCP garantisce l'invio del messaggio, dato che attende una
risposta da parte del ricevente.
Il protocollo UDP invia datagrammi, ma non si è certi se la ricezione è
avvenuta.

\subsection{Device driver}
E' un modulo che gestisce le risore fisiche dei vari moduli, tra cui NIC,
gestiscono le interruzioni del dispositivo.

\section{Trasmissione di dati}
\subsection{Invio di dati}
Il DMA presente nel NIC è il componente che accede alla memoria.

La maggior parte dei calcolatori include l'unità di gestione della memoria MMU,
che permette al processore di gestire indirizzi virtuali per ottenere una
maggiore efficienza, ma questo dispositivo è esclusivo del processore, motivo
per cui il DMA del NIC utilizzerà indirizzi fisici.

Delle porzioni di memoria della RAM saranno destinate ad essere utilizzate per
i \emph{buffer}, ovvero delle aree dove NIC può immagazzinare i dati da inviare
o da ricevere.

Al momento dell'invio di un datagramma, esso verà salvato in un buffer, quindi
inviato in rete appena possibile, quindi cancellato dalla memoria.

\subsection{Ricezione di dati}
Per la ricezione di datagrammi dei buffer devono essere sempre disponibili,
cosicchè NIC possa utilizzarli una volta ricevuto il pacchetto.

Il datagramma ricevuto sarà inserito dal DMA in un buffer, un interrupt nel
frattempo creeà nuovi buffer per possibili nuovi messaggi, quindi il sistema
legge il buffer copiandolo nel buffer dell'applicazione, direzionando l'output
verso l'utente corretto, quindi la memoria viene liberata.

Il comportamento standard di un applicazione che implementa networking 
implementa un meccanismo bloccante per cui l'applicazione rimane in attesa
fintanto che il buffer non è stato scritto al suo interno.

\subsection{Trasmissione di dati su bus ring based}
La problematica principale del DMA di tipo \emph{bus mastering} è la
necessità di dover programmare in anticipo i buffer allocati, limitandone
la capacità.

Fintanto che il DMA è impegnato in un operazione perchè in attesa del
processore verrano persi i dati nel frattempo ricevuti dalla rete.

Per risolvere questo problema si implementa una struttura dati più complicata,
integrando una piccola CPU all'interno della NIC (ring based).

\subsubsection{Ring}
Il ring è composto da un anello contenente più di un buffer, e due puntatori,
un puntatore di inizio ed uno di fine gestiti da due processori diversi;
la CPU si occupa di aggiungere elementi all'interno del ring quindi gestirà
l'indice di fine, il puntatore al primo elemento viene gestito dal processore
all'interno della NIC.
SI ottiene una coda di buffer che si possono aggiungere o togliere a seconda
se si sta gestendo un invio o ricezione di dati.

Quindi la NIC legge i buffer in memoria e usa un flag per impostare se il
buffer è libero oppure se deve essere processato.

L'unico tipo di comunicazione tra processore e DMA è la trasmissione della 
quantità di buffer che dovranno essere utilizzati al DMA.

\subsection{Commutazione}
Si rende necessario, per una questione di efficienza, un circuito fisico $R$
attraverso cui trasmettere i pacchetti.

I pacchetti sono inviati come datagrammi, e nella struttura includono il
destinatario e le informazioni trasmesse.

\subsection{Dataflow}
L' \emph{host} compila ed invia il buffer in locale al buffer di ricezione di
$R1$(router), il cui compito è di leggere il datagramma, ricavarne il
destinatario, quindi di inviarlo: l'hos può quindi cancellare il buffer.

La parte ricevente ($R2$) copia il datagramma nel suo buffer di ricezione,
quindi $R1$ può rimuovere dal proprio buffer il datagramma.
Quindi $R2$ invia il datagramma all'effettivo destinatario con un altro
\emph{store and forward}.

Ogni passaggio di trasmissione del datagramma viene chiamato \emph{hop}.

\subsection{Routing}
Identifichiamo per il processo di routing l' \emph{host}, gli endpoint della
trasmissione di pacchetti e i \emph{router}, calcolatori.
Più router possono essere collegati tra loro.

\section{Internet protocol stack}
\begin{enumerate}
  \item Physical
  \item Datalink
  \item Network
  \item Transport
  \item Application
\end{enumerate}

\subsection{Protocollo fisico}
L'unico protocollo fisico sopravissuto ed in uso è il protocollo ethernet.

Ogni richiesta sarà composta da: header, payload e trailer.

Il protocollo definisce che ad ogni host venga assegnato un indirizzo
\emph{MAC}, composto da $6byte$.

L'header conterrà come dati gli indirizzi IP e le porte dei nodi comunicanti.

Il trailer è necessario per il controllo di integrità nella rete ethernet, l'
algoritmo utilizzato è \textbf{CRC32}.

\emph{Il datalink utilizza le stesse modilità di funzionamento del protocollo
fisico}.

\subsection{Network protocol}
Il protocollo network utilizza come gestore degli indirizzi i protocolli
\emph{IPv4 e IPv6}.
Ipv4 utilizza $4byte$ per il funzionamento, significa che può gestire fino a 
circa $4$ miliardi di indirizzi, mentre ipv6 ne può utilizzare molti di più.

I primi sviluppatori dei protocolli non avevano la possibilità
di interagire direttamente con i sistemi operativi, motivo per cui si è dovuto
introdurre il concetto di \textbf{porta di comunicazione}, un numero intero
in $16bit$, con cui si identifica univocamente un numero di una porta ad una
tipologia di applicazione.

Le porte da $0$ a $1023$ sono state dedicate ai protocolli internet ed alle
applicazioni più comuni, un altra serie di porte sono sempre utilizzate per
il networking  mentre le restanti sono le così dette porte effimere che vengono
utilizzate dalle applicazioni in locale.

Quindi se la porta è la parte che un calcolatore espone ad internet, il
\emph{socket} è il corrispettivo componente nel nodo in locale, così da
associare alla richiesta una macchina ed applicazione in particolare.


Sono usati i protocolli \emph{UDP} e \emph{text}
Il protocollo \emph{UDP} invia datagrammi mentre il protocollo \emph{TCP}
permette di implementare una modalità di comunicazione più avanzata, di tipo
\emph{stream}, che permette di interagire con l'interfaccia di comunicazione
come se fossero file.

Gli indirizzi \textbf{IP} sono utilizzati per essere associati agli indirizzi
\textbf{MAC} nel network.

IL \emph{TTL} (Time To Live) definisce da quanto tempo un pacchetto è nel
network.

\emph{RFC} (Remote Function Call) cerca prima di chiamare le versioni dei
protocolli più recenti prima di doverne eseguire uno più vecchio.

\subsubsection{Indirizzi}
Ad ogni macchina corrisponde un IP ($IPv4$ o $IPv6$)
\begin{figure}[H]
    \centering
    \incfig{indirizzi}
    \caption{indirizzi}
    \label{fig:indirizzi}
\end{figure}

Un indirizzo $IPv4$ in default è composto da:
\begin{itemize}
  \item $29bit$ dedicati al network;
  \item $3bit$ dedicati all'host.
\end{itemize}
Per ovviare a problemi di carenza di indirizzi IP, si introduce il concetto
di \emph{NETMASK}, una parola composta da una serie di $1$ ed una di $0$, gli
$1$ rappresentano quanti bit sono dedicati al network, gli $0$ per l'host.

\paragraph{Indirizzi privati}
Sono definiti nel protocollo \emph{RFC 1918} dichiara che un indirizzo
\textbf{IPv4} deve essere composto da $4$ numeri decimali seguiti da punto,
inoltre dichiara che gli indirizzi che cominciano con $10.$ appartengono alla
\emph{classe A}, questi indirizzi sono i cosiddetti indirizzi privati,
utilizzabili solo in \textbf{LAN}.

Gli indirizzi di classe \textbf{B} cominciano da $192.168.0.0$ per arrivare
fino $192.168.255.255$, sono sempre indirizzi privati.


Si può configurare il router per usare il \textbf{NAT} (Network Access
translator), con lo scopo di assegnare due indirizzi IP allo stesso router,
con lo scopo di esporne uno alla rete locale e l'altro a quella internet.

Con il NAT è possibile convertire indirizzi pubblici in indirizzi privati,
direzionando i messaggio alla macchina corretta sostituendo il proprio
indirizzo alla richiesta assegnando una porta libera.

\subsection{Trasporto}
Vengono utilizzato i protocolli \emph{UDP} e \emph{TCP} e la tecnica della
\emph{3 way handshake}.

\begin{figure}[ht]
    \centering
    \incfig{3some}
    \caption{Three way handshake}
    \label{fig:3some}
\end{figure}

Il trasporto comincia con l'invio di un messaggio \textbf{SYN} (accompagnato
da \textbf{SEQ}), all'arrivo
il server risponde con un messaggio che viene chiamato \textbf{SYN-ACK}, la
\textbf{SEQ} e la \textbf{ACK};
quindi l'host invia un uteriore messaggio chiamato \textbf{ACK}, oltre che
i dati.

L'header TCP contiene una serie di informazioni tra le quali i \textbf{FLAG}
SYN e ACK oltre che la porta sorgente (\textbf{SPORT}) e di destinazione
(\textbf{DPORT}).


Vengono utilizzate $2$ parole, la \textbf{SEQ} e la \textbf{ACK}, permettono
la di realizzare l'astrazione dello stream di byte; questi numeri per motivi
di sicurezza non partono da $0$, ma da un valore casuale; lo scopo della
prima squenza di passaggi è di scambiare queste informazioni.

Inoltre \textbf{SEQ} segnala anche l'inizio dello stream di byte da leggere.

Se il messaggio viene suddiviso in tanti datagrammi cumulativi, viene inviato un unico \textbf{ACK cumulativo}.

Il \textbf{timeout} è il tempo che il processo impiega ad inviare e ricevere i
messaggi, dipende dalla lunghezza dei messaggi e dalla velocità dei
calcolatori.

La \textbf{media mobile} dà più peso agli ultimi valori, si rende necessaria
per calcolare il tempo di timeout.
\[
  \text{Estimated }=(1-\alpha)\times\text{ Estimated}+\alpha\text{ SampleRTT}
\]

Inoltre si usa una stime della variabilità:
\[
  \text{Dev}=(1-\beta)\times\text{ Dev}+\beta\times\mid\text{SampleRTT}-
  \text{Estimated}\mid
\]

I parametri $\alpha,\beta$ hanno un valore consigliato: $\alpha=\dfrac{1}{8}$,
$\beta=\dfrac{1}{4}$.

Quindi inizialmente viene assegnato un valore fisso viene inizialmente
assegnato ad \emph{Estimated} e \emph{Dev}, quindi il primo messaggio viene
inviato, quindi nel primo scambuio, in cui il client riceve il \emph{SYN-ACK},
si ottiene il primo \emph{SampleRTT}.

Quindi si possono comparare i valori \emph{Estimated} e \emph{Dev},
(Deviazione) ogni scambio di \emph{ACK e SIN-ACK}.

Il \textbf{timeout sarà}:
\[
  \text{Time-out}=\text{Estimated}+4\times\text{ Dev}
\]

\subsubsection{Flow control}
Il motivo principale della perdita di messaggi è la mancanza di
sincronizzazione, un tempo era molto probabile ricevere messaggi corrotti,
ora la perdita di messaggi è legata alla mancanza di buffer liberi di
ricezione.

Il \textbf{mittente} avrà un buffer di ricezione (TX buffer), così come
il destinatario (RX buffer), nei quali i datagramm vengono ricevuti.

Per garantire che vi siano sempre buffer di ricezione liberi sarà necessario
comunicare all'interlocutore il numero di buffer allocati.

All'interno dell'header \textbf{TCP} vi sarà un campo \textbf{receive window}
che contiene la grandezza dei buffer di ricezione del destinatario.

I messaggi saranno inviati o alla ricezione di un \textbf{ACK} o alla scadenza
del \textbf{TIMEOUT}.

In generale, \emph{UDP} utilizza un approccio ottimistico per cui in una
comunicazione fluida è più efficiente rispetto a \emph{TCP} che si accerta
che ogni messaggio venga ricevuto correttamente.

\subsubsection{Congestion control}
Il \textbf{TCP} implementa anche un controllo di congestione oltre al \emph{
flow control}, è necessario per ridurre la perdita di messaggi sulla reta,
ma non da parte del destinatario, ma dai \emph{router} che implementano lo
\emph{store and forward}.

Quindi è il \emph{router} che rileva la congestione di dati (mancanza di
buffer) e rallenta la ricezione di dati.

Il congestion control avviene in tre fasi:
\begin{enumerate}
  \item \textbf{slow start}: invio di pochi bytes;
  \item dopo l' \textbf{ACK}, raddoppio la quantità di datagrammi inviati;
  \item quindi se i dati inviati diventano troppo grandi, si torna ad un
    passaggio indietro e si aumentano a passi i dati inviati.
\end{enumerate}
