\section{Accenni al funzionamento di un calcolatore}
Un calcolatore è generalmente composto da:
\begin{itemize}
  \item la $CPU$, esegue le istruzioni, tiene in memoria ($Instruction Register$)
    l'istruzione corrente e la posizione dell'istruzione nella RAM ($P.C.$);
  \item la $RAM$, tiene in memoria le istruzioni da eseguire, certe sezioni
    sono riservate per specifiche funzioni ($stack$, $SP$, $BP$);
  \item dei moduli, come un disco fisso o altro;
  \item la $NIC$, che permette di inviare e ricevere pacchetti in rete.
\end{itemize}

\subsection{Registri}
\section{Networking}
Vengono effettuate delle syscall, per eseguire operazioni necessario all'invio di dati.
Per esempio la syscall send, copia dalla ram una certa sezione di memoria nel NIC,
che verrà inviata in rete.
???

\subsection{TCP/UDP}
Il protocollo TCP garantisce l'invio del messaggio, dato che attende una risposta
da parte del ricevente.

Il protocollo UDP invia datagrammi, ma non si è certi se la ricezione è avvenuta.
\subsubsection{Device driver}
E' un modulo che gestisce le rusirse fusuche dei vari moduli, tra cui NIC,
gestiscono le interruzioni del dispositivo.

\subsection{Invio}
Il DMA presente nel NIC è il componente che accede alla memoria.

L'unità di gestione della memoria MMU,
permette di utilizzare indirizzi virtuali in indirizzi fisici,
quindi mentre il processore utilizza indirizzi virtuali,
il DMA del NIC utilizzerà indirizzi fisici.

Interrupt, buffer
\subsection{Ricezione}
Per la ricezione di pacchetti devono essere sempre disponibili dei buffer,
su cui NIC può scrivere una volta ricevuto il pacchetto.

Il pacchetto in arrivo viene processato dal NIC quindi con il DMA inserito nel buffer,
quindi un interrupt crea nuovi buffer per possibili nuovi messaggi,
quindi il sistema legge il buffer copiandolo nel buffer dell'applicazione,
direzionando quindi l'output verso l'utente corretto,
quindi il buffer di ricezione può essere riutilizzato per nuovi pacchetti.

Il comportamento standard di un applicazione che implementa networking è un
meccanismo bloccante per cui l'applicazione rimane in attesa fintanto che il
buffer non è stato scritto al suo interno.

\section{trasmissione di datu su bus ring based}
La problematica principale del DMA di tipo bus mastering è che deve essere
programmato in anticipo, ovvero è limitata da quanti buffer sono stati programmati
per essere utilizzati dal DMA ed è dipendente dalla velocità del processore a
liberare il buffer, per cui fintanto che il DMA è occupato, verrano persi i
dati nel frattempo ricevuti dalla rete.


Quindi si implementa una struttura dati più complicata, integrando una piccola
CPU all'interno della NIC (ring based).
\subsection{Ring}
Il ring è composto da un anello contenente più di un buffer, e due puntatori,
un puntatore di inizio ed uno di fine gestiti da due processori diversi;
la CPU si occupa di aggiungere elementi all'interno del ring quindi gestirà
l'indice di fine, il puntatore al primo elemento viene gestito dal processore
all'interno della NIC.
SI ottiene una coda di buffer che si possono aggiungere o togliere a seconda
se si sta gestendo un invio o ricezione di dati.

Quindi la NIC legge i buffer in memoria e usa un flag per impostare se il buffer
è libero oppure se deve essere processato.
Quindi il'unica comunicazione tra processore e DMA è la comunicazione della 
quantità di buffer che dovranno essere utilizzati al DMA.

\subsection{Commutazione}
Si rende necessario, per una questione di efficienza, un circuito fisico $R$
attraverso cui trasmettere i pacchetti.

I pacchetti sono inviati come datagrammi, e nella struttura includono il
destinatario e le informazioni trasmesse.

\subsubsection{Workflow}
La macchina che vuole inviare un datagramma \emph{host} compila e viene mandato
dal buffer in locale al buffer di ricezione di $R1$(router), il cui compito è di
leggere il datagramma, ricavarne il destinatario, quindi di inviarlo, la
macchina può quindi cancellare dal buffer il dato.

La parte ricevente ($R2$) copia il datagramma nel suo buffer di ricezione,
quindi $R1$ può rimuovere dal proprio buffer il datagramma.
Quindi $R2$ invia il datagramma all'effettivo destinatario con un altro
\emph{store and forward}.

Ogni passaggio di trasmissione del datagramma viene chiamato \emph{hop}.

\subsection{Routing}
Identifichiamo per il processo di routing lo \emph{host}, gli endpoint della
trasmissione di pacchetti e i \emph{router}, calcolatori.
Più router possono essere collegati tra loro.

\subsection{Internet protocol stack}
\begin{enumerate}
  \item Physical
  \item Datalink
  \item Network
  \item Transport
  \item Application
\end{enumerate}

\subsubsection{Protocollo fisico}
L'unico protocollo fisico sopravissuto ed in uso è il protocollo ethernet.

Ogni richiesta sarà composta da: header, payload e trailer.

Il protocollo definisce che ad ogni host venga assegnato un indirizzo
\emph{MAC}, composto da $6byte$.

L'header conterrà come dati gli indirizzi IP e le porte dei nodi comunicanti.

Il trailer è necessario per il controllo di integrità nella rete ethernet, l'
algoritmo utilizzato è \textbf{CRC32}.

\emph{Datalink utilizza le stesse modilià di funzionamento del protocollo fisico}.

\subsubsection{Network protocol}
Il protocollo network utilizza come gestore degli indirizzi i protocolli
\emph{IPv4 e IPv6}.
Ipv4 utilizza 4 byte per il funzionamento, significa che può gestire fino a 
circa $4$ miliardi di indirizzi, mentre ipv6 ne può utilizzare molti di più.

Gli indirizzi \textbf{IP} sono utilizzati per essere associati agli indirizzi
\textbf{MAC} nel network.

IL \emph{TTL} (Time To Live) definisce da quanto tempo un pacchetto è nel
network.

\emph{RFC} (Remote Function Call) cerca prima di chiamare le versioni dei
protocolli più recenti prima di doverne eseguire uno più vecchio.

\subsubsection{Trasporto}
Vengono utilizzato i protocolli \emph{UDP} e \emph{TCP}.

I primi sviluppatori dei protocollo di comunicazione non avevano la possibilità
di interagire direttamente con i sistemi operativi, motivo per cui si è dovuto
introdurre il concetto di \textbf{porta di comunicazione}, un numero intero
in $16bit$, con cui si identifica univocamente un numero di una porta ad una
tipologia di applicazione.

Le porte da $0$ a $1023$ sono state dedicate ai protocolli internet ed alle
applicazioni più comuni, un altra serie di porte sono sempre utilizzate per
il networking  mentre le restanti sono le così dette porte effimere che vengono
utilizzate dalle applicazioni in locale.

Le porte da $0$ a $1023$ sono state dedicate ai protocolli internet ed alle
applicazioni più comuni, un altra serie di porte sono sempre utilizzate per
il networking  mentre le restanti sono le così dette porte effimere che vengono
utilizzate dalle applicazioni in locale.

Quindi se la porta è la parte che un calcolatore espone ad internet, il
\emph{socket} è il corrispettivo componente nel nodo in locale, così da
associare alla richiesta una macchina ed applicazione in particolare.
