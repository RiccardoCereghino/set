\chapter{Introduzione ai sistemi operativi}
\begin{figure}[ht]
    \centering
    \incfig{struttura}
    \caption{Struttura base di un calcolatore}
    \label{fig:struttura}
\end{figure}

Lo scopo di questa sezione è di virtualizzare le componenti fisiche di un
calcolatore per renderne più facile l'utilizzo.

Sinonimi di \emph{sistema operativo} sono \textbf{macchina virtuale} (virtual
machine) e \textbf{gestore dlle risorse} (resource manager).

\section{Virtualizzazione della CPU}
L'unica nota in questo programma è l'utilizzo della funzione \emph{spin()}, che
controlla l'orologio di sistema fino a quanto $1$ minuto non è passato, quindi
riprende l'esecuzione.

\lstinputlisting[caption=Interazione con la  CPU usando la funzione spin()]{listings/cpu.c}

Da notare che se il programma viene eseguito con un comando del tipo:
\begin{lstlisting}[language=bash,caption=Esecuzione in concorrenza]
prompt> ./cpu A & ./cpu B &./cpu C & ./cpu D
[7353]
[7354]
[7355]
[7356]
A
B
D
C
A
B
D
C
A
...
\end{lstlisting}

Possiamo osservare che sembra che vengano eseguiti simultaneamente quattro
programmi diversi, ciò è dovuto alla \emph{virtualizzazione della CPU}.

\section{Memoria virtualizzata}
\lstinputlisting[caption=Dimostrazione dell'utilizzo di indirizzi virtuali]{listings/mem.c}

La memoria \textbf{RAM} è generalmente virtualizzata, difatti se eseguiamo
il programma precedente con un comando tipo:
\begin{lstlisting}[language=bash,caption=Esecuzione in concorrenza]
prompt > ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) address pointed by p: 0x200000
(24114) address pointed by p: 0x200000
(24113) p: 1
(24114) p: 1
(24113) p: 2
(24114) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
...
\end{lstlisting}

Possiamo osservare il funzionamento della virtualizzazione della memoria,
infatti ogni programma è lanciato in un proprio \textbf{virtual address space};
semplifica la gestione della memoria per il programma ed è mappato ad una
sezione della memoria fisica.

\section{Periferiche}
Nell'interazione di un calcolatore con le periferiche, è il kernel che
interagisce direttamente con l' hardware, mentre le applicazioni possono
utilizzare le periferiche solo attraverso il kernel.


Vi sono $4$ diversi livelli di privilegi per interagire con i dispositivi:
\begin{itemize}
  \item $0$, il livello più privilegiato, utilizzato dal kernel;
  \item $1$ solitamente non utilizzato;
  \item $2$ solitamente non utilizzato;
  \item $3$ il livello meno provilegiato, utilizzato da tutti gli utenti
    compreso l'utente di \emph{root}.
\end{itemize}

Se l'utende richiede un interazione con una periferica, un comando di
\emph{TRAP} viene inviato al kernel, il quale restituise un comando di
\emph{return from TRAP}.

\section{Spazi di indirizzamento}
Ad ogni processo in esecuzione corrisponde un \emph{address space}, una
virtualizzazione della memoria che comporta diversi vantaggi, tra cui non
permettere ai programmi di modificare memoria non nella propria \emph{address
space} ed in generale un efficienza maggiore.


Un processo è composto da:
\begin{itemize}
  \item \textbf{codice:} statico, regione fissa;
  \item \textbf{dati:} regione fissa;
  \item \textbf{stack:} regione dinamica, può crescere o diminuire;
  \item \textbf{heap:} regione dinamica.
\end{itemize}


Quindi l'address space è composto, in ordine, da:
\begin{itemize}
  \item \textbf{codice del programma:} dove risiedono le istruzioni;
  \item \textbf{heap:} contiene i dati creati con i \emph{malloc} e le
    strutture dinamiche, cresce verso il basso;
  \item \textbf{memoria libera:} che può essere occupata dallo heap e dallo
    stack;
  \item \textbf{stack:} dove risiedono le variabili locali, i valori di ritorno
    delle funzioni, etc. e cresce verso l'alto.
\end{itemize}


All'interno del sistema operativo è contenuta una struttura dati che contiene
informazioni relative ai processi in memoria, \textbf{PCB} (Process Control
Bloc).

\subsection{Virtualizzazione}
Gli obiettivi della virtualizzazione sono: trasparenza, efficienza e protezione
ovvero un programma non deve accorgersi che sta utilizzando solo una porzione
della memoria disponibile.


Per implementare queste funzioni si utilizza una \textbf{MMU}; al suo interno
salviamo un registro chiamato base, il quale cambia a seconda del programma
in esecuzione.

Questa implementazione non è corretta in quanto non abbiamo indicato un limite
al valore che possiamo assegnare alla base, quindi i processi potrebbero
accedere a memoria successiva alla loro, per cui sono gestiti anche i limiti
su quali valori posso assegnare al registro base.

Nel caso di un \textit{segmentation fault} (errore relativo all'accesso di
memoria non propria) vengono sollevati gli \textbf{interrupt handlers}, e gli
\textbf{exception handlers}, i quali gestiscono le eccezioni.
Altri errori simili che sollevano un interrupt sono la divisione per $0$.

Gli interrupt possono anche essere utilizzati per interagire con il sistema
operativo, il sistema operativo può disabilitare gli interrupt.

\subsection{Frammentazione}
La frammentazione interna è composta dalla memoria allocata per un programma,
ma non utilizzata.

La frammentazione esterna invece è la memoria che non viene utilizzata perchè
non abbastanza grande da ospitare un processo e tra due address spaces.
